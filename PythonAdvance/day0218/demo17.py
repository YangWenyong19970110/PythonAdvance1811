"""
垃圾回收
1，引用计数
2，标记清除（就是为了解决引用计数的循环引用问题）
"""
import sys
# print(sys.getrefcount("hello world"))
# s1 = "hello world"
# s2 = s1
# del s2
# print(sys.getrefcount("hello world"))

# l = [ x for x in range(1000)]  #+1
# l2 = [ x for x in range(1000)] #+1
# print(sys.getrefcount(l))
# print(sys.getrefcount(l2))
# l2.append(l)#+1
# print(sys.getrefcount(l))
# l.append(l2) #+1
# print(sys.getrefcount(l2))
# del l #-1
# del l2 #-1
# 此时l 和l2 所在内存的引用计数都是原始值+1
# 内存泄露：在程序运行过程中，产生的始终无法访问到的内存地址

# 在回收内存之前 进行标记

# 引用计数：指内存的 技术
# a = [1,2] 引用计数+1 其实是【1,2】列表所在内存的引用+1

"""
标记清除：在进行清除变量之后对每一个删除的对象引用计数-1
如果引用计数变为0 就暂时放入死亡容器
如果引用计数部位0 检测是否引用到了死亡容器容器中对象 
如果引用到了死亡容器对象，将死亡容器对象拿出来放入存活容器

"""

l1 = [1,2] #此时列表【1,2】 存储在内存块A中 此时内存A引用计数1
l2 = [3,4] #此时列表【3,4】 存储在内存块B中 此时内存B引用计数1
l1.append(l2)  #此时内存B 引用计数为2
l2.append(l1)  # 此时内存A 引用计数为2
del l1  #此时内存A 引用计数为1
del l2 #此时内存B引用计数为1
# 内存A 内存B 无法访问永远丢失 导致内存泄露
l3 = [5,6]
l4 = [7,8]
l3.append(l4)
l4.append(l3)

del l3  # 此时【5,6】 内存引用计数1  【7，8】内存计数为2
l5 = [9, 10]

# 标记清除
# 第一步查看删除对象后对象所在内存的引用计数，都减去1
# 【1,2】 计数为 0 死亡容器
# 【3,4】 计数为 0 死亡容器
#  【5,6】 计数 为0  死亡容器
#  【7,8 ，【5,6】】计数为1 存活容器

# 第二步 遍历存活容器对象 查看是否引用到了死亡容器对象
# 需要将【5,6】 从死亡容器中拿出放入存活容器

# 分代收集: 目的是为了确定 对哪些对象进行标记清除
# 每标记清除一次 称为1代 代数越高 证明存活能力强，执行标记清除频率低

# 小整数对象与intern机制
# 某些特定的对象引用计数为0 也不回收，而是放入对象池（用来存储小整数的池子）
# 有了对象池：系统载频帆的使用小整数时 不需要每次开辟空间和回收空间